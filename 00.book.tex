\documentclass[pdftex,12pt, oneside]{article}

%\usepackage[paperwidth=8.5in, paperheight=13in]{geometry} % Folio
\usepackage[paperwidth=8.27in, paperheight=11.69in]{geometry} % A4

\usepackage{makeidx}         % allows index generation
\usepackage{graphicx}        % standard LaTeX graphics tool
                             % when including figure files
\usepackage[bottom]{footmisc}% places footnotes at page bottom
\usepackage[english]{babel}
\usepackage{enumerate}
\usepackage{paralist}
\usepackage{float}
\usepackage{gensymb}  
\usepackage{listings}
\usepackage{color}
\usepackage{mathtools} % atau \usepackage{amsmath}
\renewcommand{\baselinestretch}{1.5}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolor}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolor},
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  stringstyle=\color{codepurple},
  basicstyle=\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
}

\lstset{style=mystyle}


\begin{document}
\sloppy % biar section ga melebar melewati kertas

\begin{center}
{\large \textit{SOURCE CODE} PROGRAM \textit{WEB SERVICE} PBB-P2.}
\\[1cm]
25 November 2016\\
Priyanto Tamami, S.Kom.
\end{center}

%\frontmatter%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\textit{SOURCE CODE} PEMBUATAN TABEL}

\textit{Source code} untuk pembuatan tabel menggunakan bahasa SQL biasa, adapun tabel yang digunakan ada 4 (empat) buah dengan rincian sebagai berikut :


  \subsection{Tabel SPPT}
  
  Tabel ini sudah ada terlebih dahulu sebagai tempat untuk menampung seluruh ketetapan yang ada pada PBB-P2, \textit{source code} dari pembuatan tabel SPPT ini adalah sebagai berikut :
  
  \begin{lstlisting}
CREATE TABLE SPPT (
  KD_PROPINSI CHAR(2) NOT NULL,
  KD_DATI2 CHAR(2) NOT NULL,
  KD_KECAMATAN CHAR(3) NOT NULL,
  KD_KELURAHAN CHAR(3) NOT NULL,
  KD_BLOK CHAR(3) NOT NULL,
  NO_URUT CHAR(4) NOT NULL, 
  KD_JNS_OP CHAR(1) NOT NULL, 
  THN_PAJAK_SPPT CHAR(4) NOT NULL,
  SIKLUS_SPPT NUMBER(2,0) NOT NULL,
  KD_KANWIL_BANK CHAR(2) NOT NULL,
  KD_KPPBB_BANK CHAR(2) NOT NULL,
  KD_BANK_TUNGGAL CHAR(2) NOT NULL,
  KD_BANK_PERSEPSI CHAR(2) NOT NULL,
  KD_TP CHAR(2) NOT NULL,
  NM_WP_SPPT VARCHAR2(30) NOT NULL,
  JLN_WP_SPPT VARCHAR2(30) NOT NULL,
  BLOK_KAV_NO_WP_SPPT VARCHAR2(30),
  RW_WP_SPPT CHAR(2),
  RT_WP_SPPT CHAR(3),
  KELURAHAN_WP_SPPT VARCHAR2(30),
  KOTA_WP_SPPT VARCHAR2(30),
  KD_POS_WP_SPPT VARCHAR2(5),
  NPWP_SPPT VARCHAR2(15),
  NO_PERSIL_SPPT VARCHAR2(5),
  KD_KLS_TANAH CHAR(3) DEFAULT 'XXX' NOT NULL,
  THN_AWAL_KLS_TANAH CHAR(4) DEFAULT '1986' NOT NULL,
  KD_KLS_BNG CHAR(3) DEFAULT 'XXX' NOT NULL,
  THN_AWAL_KLS_BNG CHAR(4) DEFAULT '1986' NOT NULL,
  TGL_JATUH_TEMPO_SPPT DATE NOT NULL,
  LUAS_BUMI_SPPT NUMBER(12,0) DEFAULT 0 NOT NULL,
  LUAS_BNG_SPPT NUMBER(12,0) DEFAULT 0 NOT NULL,
  NJOP_BUMI_SPPT NUMBER(15,0) DEFAULT 0 NOT NULL,
  NJOP_BNG_SPPT NUMBER(15,0) DEFAULT 0 NOT NULL,
  NJOP_SPPT NUMBER(15,0) NOT NULL,
  NJOPTKP_SPPT NUMBER(8,0) NOT NULL,
  NJKP_SPPT NUMBER(5,2),
  PBB_TERHUTANG_SPPT NUMBER(15,0) NOT NULL,
  FAKTOR_PENGURANG_SPPT NUMBER(12,0),
  PBB_YG_HARUS_DIBAYAR_SPPT NUMBER(15,0) NOT NULL,
  STATUS_PEMBAYARAN_SPPT CHAR(1) DEFAULT '0' NOT NULL,
  STATUS_TAGIHAN_SPPT CHAR(1) DEFAULT '0' NOT NULL,
  STATUS_CETAK_SPPT CHAR(1) DEFAULT '0' NOT NULL,
  TGL_TERBIT_SPPT DATE NOT NULL,
  TGL_CETAK_SPPT DATE DEFAULT SYSDATE NOT NULL,
  NIP_PENCETAK_SPPT CHAR(9) NOT NULL,
  CONSTRAINT PK_E6 PRIMARY KEY (KD_PROPINSI, KD_DATI2, KD_KECAMATAN, KD_KELURAHAN, KD_BLOK, NO_URUT, KD_JNS_OP, THN_PAJAK_SPPT)
  FOREIGN KEY (NIP_PENCETAK_SPPT) REFERENCES PEGAWAI(NIP),
  FOREIGN KEY (KD_PROPINSI, KD_DATI2, KD_KECAMATAN, KD_KELURAHAN, KD_BLOK, NO_URUT,       KD_JNS_OP) REFERENCES DAT_OBJEK_PAJAK(KD_PROPINSI, KD_DATI2, KD_KECAMATAN, KD_KELURAHAN, KD_BLOK, NO_URUT, KD_JNS_OP),
  FOREIGN KEY (KD_KANWIL_BANK, KD_KPPBB_BANK, KD_BANK_TUNGGAL, KD_BANK_PERSEPSI, KD_TP) REFERENCES TEMPAT_PEMBAYARAN(KD_KANWIL, KD_KPPBB, KD_BANK_TUNGGAL, KD_BANK_PERSEPSI, KD_TP),
  FOREIGN KEY(KD_KLS_BNG, THN_AWAL_KLS_BNG) REFERENCES KELAS_BANGUNAN(KD_KLS_BNG, THN_AWAL_KLS_BNG),
  FOREIGN KEY(KD_KLS_TANAH, THN_AWAL_KLS_TANAH) REFERENCES KELAS_TANAH(KD_KLS_TANAH, THN_AWAL_KLS_TANAH)
);    
  \end{lstlisting}
  
  \subsection{Tabel PEMBAYARAN\_SPPT}
  
  Tabel ini pun sudah ada pada basis data yang digunakan sebagai tempat menyimpan atau mencatat transaksi pembayaran. \textit{Source code} dari pembuatan tabel ini adalah sebagai berikut :
  
  \begin{lstlisting}
CREATE TABLE PEMBAYARAN_SPPT (
  KD_PROPINSI CHAR(2) NOT NULL,
  KD_DATI2 CHAR(2) NOT NULL,
  KD_KECAMATAN CHAR(3) NOT NULL,
  KD_KELURAHAN CHAR(3) NOT NULL,
  KD_BLOK CHAR(3) NOT NULL,
  NO_URUT CHAR(4) NOT NULL,
  KD_JNS_OP CHAR(1) NOT NULL,
  THN_PAJAK_SPPT CHAR(4) NOT NULL,
  PEMBAYARAN_SPPT_KE NUMBER(2,0) NOT NULL,
  KD_KANWIL_BANK CHAR(2) NOT NULL,
  KD_KPPBB_BANK CHAR(2) NOT NULL,
  KD_BANK_TUNGGAL CHAR(2) NOT NULL,
  KD_BANK_PERSEPSI CHAR(2) NOT NULL,
  KD_TP CHAR(2) NOT NULL,
  DENDA_SPPT NUMBER(12,0),
  JML_SPPT_YG_DIBAYAR NUMBER(15,0) NOT NULL,
  TGL_PEMBAYARAN_SPPT DATE NOT NULL,
  TGL_REKAM_BYR_SPPT DATE DEFAULT SYSDATE NOT NULL,
  NIP_REKAM_BYR_SPPT CHAR(9) NOT NULL,
  CONSTRAINT PK_G1 PRIMARY KEY(KD_PROPINSI, KD_DATI2, KD_KECAMATAN, KD_KELURAHAN, KD_BLOK, NO_URUT, KD_JNS_OP, THN_PAJAK_SPPT, PEMBAYARAN_SPPT_KE, KD_KANWIL_BANK, KD_KPPBB_BANK, KD_BANK_TUNGGAL, KD_BANK_PERSEPSI, KD_TP),
  FOREIGN KEY (NIP_REKAM_BYR_SPPT) REFERENCES PEGAWAI(NIP),
  FOREIGN KEY (KD_PROPINSI, KD_DATI2, KD_KECAMATAN, KD_KELURAHAN, KD_BLOK, NO_URUT, KD_JNS_OP, THN_PAJAK_SPPT) REFERENCES SPPT(KD_PROPINSI, KD_DATI2, KD_KECAMATAN, KD_KELURAHAN, KD_BLOK, NO_URUT, KD_JNS_OP, THN_PAJAK_SPPT),
  FOREIGN KEY (KD_KANWIL_BANK, KD_KPPBB_BANK, KD_BANK_TUNGGAL, KD_BANK_PERSEPSI, KD_TP) REFERENCES TEMPAT_PEMBAYARAN(KD_KANWIL, KD_KPPBB, KD_BANK_TUNGGAL, KD_BANK_PERSEPSI, KD_TP)
);
  \end{lstlisting}
  
  \subsection{Tabel LOG\_TRX\_PEMBAYARAN}
  
  Tabel ini digunakan untuk menyimpan atau mencatat proses transaksi pembayaran yang berhasil dilakukan. \textit{Source code} untuk tabel LOG\_TRX\_PEMBAYARAN ini adalah sebagai berikut :
  
  \begin{lstlisting}    
CREATE TABLE LOG_TRX_PEMBAYARAN (	
  NOP VARCHAR2(18 BYTE) NOT NULL,
  THN VARCHAR2(4 BYTE) NOT NULL,
  NTPD VARCHAR2(30 BYTE) NOT NULL,
  POKOK NUMBER,
  NAMA_WP VARCHAR2(50 BYTE),
  ALAMAT_OP VARCHAR2(150 BYTE),
  MATA_ANGGARAN VARCHAR2(15 BYTE),
  MA_SANKSI VARCHAR2(20 BYTE),
  DENDA NUMBER,
  PEMBAYARAN_KE NUMBER(2,0),
  IP_CLIENT VARCHAR2(30 BYTE),
  CONSTRAINT LOG_TRX_PEMBAYARAN_PK PRIMARY KEY 
    ("NOP", "THN", "NTPD"));  
  \end{lstlisting}
  
  \subsection{Tabel LOG\_REVERSAL}
  
  Tabel ini digunakan untuk mencatat historis transaksi \textit{reversal} pembayaran yang telah selesai dilakukan. \textit{Source code} untuk tabel ini adalah sebagai berikut :
  
  \begin{lstlisting}
CREATE TABLE LOG_REVERSAL (	
  NOP VARCHAR2(20 BYTE) NOT NULL,
  THN VARCHAR2(4 BYTE) NOT NULL,
  NTPD VARCHAR2(30 BYTE) NOT NULL,
  IP_CLIENT VARCHAR2(30 BYTE),
  CONSTRAINT LOG_REVERSAL_PK PRIMARY KEY ("NOP", "THN", "NTPD"));    
  \end{lstlisting}


\section{\textit{SOURCE CODE STORE PROCEDURE}}

\textit{Store procedure} pada basis data akan terbagi menjadi 3 (tiga) bagian. Fungsi dari \textit{store procedure} ini adalah sekumpulan baris program yang menggunakan bahasa PL/SQL yang didukung oleh sistem basis data Oracle, baris demi baris akan dijalankan oleh sistem basis data, yang memudahkan pemindahan data antar beberapa tabel terjadi dengan sangat cepat. Ketiga bagian \textit{store procedure} yang digunakan pada sistem aplikasi ini adalah sebagai berikut :

\subsection{\textit{STORE PROCEDURE} SPPT\_TERHUTANG}

\textit{Store procedure} ini akan bertugas melakukan \textit{query} ke basis data untuk kepentingan menampilkan informasi tagihan PBB-P2. Kode untuk \textit{store procedure} ini adalah sebagai berikut :

  \begin{lstlisting}
create or replace procedure sppt_terhutang(c_sppt out sys_refcursor, nop in varchar, thn in varchar) is
  v_kdPropinsi sppt.kd_propinsi%type;
  v_kdDati2 sppt.kd_dati2%type;
  v_kdKecamatan sppt.kd_kecamatan%type;
  v_kdKelurahan sppt.kd_kelurahan%type;
  v_kdBlok sppt.kd_blok%type;
  v_noUrut sppt.no_urut%type;
  v_kdJnsOp sppt.kd_jns_op%type;
begin
  v_kdPropinsi := substr(nop,1,2);
  v_kdDati2 := substr(nop,3,2);
  v_kdKecamatan := substr(nop,5,3);
  v_kdKelurahan := substr(nop,8,3);
  v_kdBlok := substr(nop,11,3);
  v_noUrut := substr(nop,14,4);
  v_kdJnsOp := substr(nop,18,1);

  open c_sppt for
    SELECT
    (sppt.kd_propinsi
    ||sppt.kd_dati2
    ||sppt.kd_kecamatan
    ||sppt.kd_kelurahan
    ||sppt.kd_blok
    ||sppt.no_urut
    ||sppt.kd_jns_op)              AS NOP,
    sppt.thn_pajak_sppt            AS THN,
    sppt.nm_wp_sppt                AS NAMA,
    kel.nm_kelurahan||' - '||kec.nm_kecamatan as "ALAMAT_OP",
    sppt.pbb_yg_harus_dibayar_sppt AS POKOK,
    case
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 1) then ceil(1 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 2) then ceil(2 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 3) then ceil(3 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 4) then ceil(4 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 5) then ceil(5 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 6) then ceil(6 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 7) then ceil(7 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 8) then ceil(8 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 9) then ceil(9 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 10) then ceil(10 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 11) then ceil(11 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 12) then ceil(12 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 13) then ceil(13 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 14) then ceil(14 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate between (tgl_jatuh_tempo_sppt+1) and add_months(tgl_jatuh_tempo_sppt, 15) then ceil(15 * 0.02 * pbb_yg_harus_dibayar_sppt)
      when thn > '2013' and sysdate > add_months(tgl_jatuh_tempo_sppt, 15) then ceil(15 * 0.02 * pbb_yg_harus_dibayar_sppt)
      else 0
    end as denda,
    sppt.status_pembayaran_sppt
  FROM sppt
  join ref_kecamatan kec on (
     kec.kd_propinsi = sppt.kd_propinsi
    and kec.kd_dati2  = sppt.kd_dati2
    and kec.kd_kecamatan = sppt.kd_kecamatan)
  join ref_kelurahan kel on (
     kel.kd_propinsi = sppt.kd_propinsi
    and kel.kd_dati2 = sppt.kd_dati2
    and kel.kd_kecamatan = sppt.kd_kecamatan
    and kel.kd_kelurahan = sppt.kd_kelurahan)
  where
    sppt.kd_propinsi = v_kdPropinsi and
    sppt.kd_dati2 = v_kdDati2 and
    sppt.kd_kecamatan = v_kdKecamatan and
    sppt.kd_kelurahan = v_kdKelurahan and
    sppt.kd_blok = v_kdBlok and
    sppt.no_urut = v_noUrut and
    sppt.kd_jns_op = v_kdJnsOp and
    sppt.thn_pajak_sppt = thn;
end;
  \end{lstlisting}

\subsection{\textit{STORE PROCEDURE} PROSES\_PEMBAYARAN}

\textit{Store procedure} ini digunakan untuk melakukan pencatatan pembayaran. Kode untuk \textit{store procedure} ini adalah sebagai berikut :

  \begin{lstlisting}
create or replace procedure proses_pembayaran(c_proses_pembayaran out sys_refcursor,
    nop in varchar, thn in varchar, tgl_bayar in date, ip_client in varchar)
is
  v_kdPropinsi sppt.kd_propinsi%type;
  v_kdDati2 sppt.kd_dati2%type;
  v_kdKecamatan sppt.kd_kecamatan%type;
  v_kdKelurahan sppt.kd_kelurahan%type;
  v_kdBlok sppt.kd_blok%type;
  v_noUrut sppt.no_urut%type;
  v_kdJnsOp sppt.kd_jns_op%type;
  v_pokokTemp sppt.pbb_yg_harus_dibayar_sppt%type;
  v_dendaTemp numeric;
  v_tglJatuhTempo sppt.tgl_jatuh_tempo_sppt%type;
  v_kdKanwilBank sppt.kd_kanwil_bank%type;
  v_kdKppbbBank sppt.kd_kppbb_bank%type;
  v_kdBankTunggal sppt.kd_bank_tunggal%type;
  v_kdBankPersepsi sppt.kd_bank_persepsi%type;
  v_kdTp sppt.kd_tp%type;
  v_statusPembayaranSppt sppt.status_pembayaran_sppt%type;
  v_pembayaranKe numeric;
  v_tglRekam date;
  v_jamRekam timestamp;

  v_ntpd varchar2(50);
  v_namaWp sppt.nm_wp_sppt%type;
  v_panjangNamaWp number;
  v_znt dat_op_bumi.kd_znt%type;
  v_nilaiSistemBumi dat_op_bumi.nilai_sistem_bumi%type;
  v_mataAnggaran varchar2(20); -- '4.1.1.11.01'; -- ref_jns_sektor.kd_sektor = 02
                             -- '4.1.1.11.02'; -- ref_jns_sektor.kd_sektor = 01
  v_mataAnggaranSanksi varchar2(20);
  v_kdSektor ref_kelurahan.kd_sektor%type;
  v_nmKelurahan ref_kelurahan.nm_kelurahan%type;
  v_nmKecamatan ref_kecamatan.nm_kecamatan%type;

begin
  -- error code in c_proses_pembayaran
  -- 01 : NO DATA FOUND
  -- 02 : POKOK PEMBAYARAN BERBEDA DENGAN TAGIHAN
  -- 03 : SPPT SUDAH TERBAYAR
  -- 04 : TAGIHAN SPPT DIBATALKAN

  -- set parameter nop
  v_kdPropinsi := substr(nop,1,2);
  v_kdDati2 := substr(nop,3,2);
  v_kdKecamatan := substr(nop,5,3);
  v_kdKelurahan := substr(nop,8,3);
  v_kdBlok := substr(nop,11,3);
  v_noUrut := substr(nop,14,4);
  v_kdJnsOp := substr(nop,18,1);

  -- query data dari tabel sppt
  select pbb_yg_harus_dibayar_sppt, tgl_jatuh_tempo_sppt, kd_kanwil_bank,
    kd_kppbb_bank, kd_bank_tunggal, kd_bank_persepsi, kd_tp, status_pembayaran_sppt,
    nm_wp_sppt
  into v_pokokTemp, v_tglJatuhTempo, v_kdKanwilBank,
    v_kdKppbbBank, v_kdBankTunggal, v_kdBankPersepsi, v_kdTp, v_statusPembayaranSppt,
    v_namaWp
  from sppt
  where thn_pajak_sppt = thn
    and kd_propinsi = v_kdPropinsi
    and kd_dati2 = v_kdDati2
    and kd_kecamatan = v_kdKecamatan
    and kd_kelurahan = v_kdKelurahan
    and kd_blok = v_kdBlok
    and no_urut = v_noUrut
    and kd_jns_op = v_kdJnsOp;

  if(v_tglJatuhTempo = NULL) then
    open c_proses_pembayaran for
      select '01' as kode_error from dual; -- NO DATA FOUND
    goto exit_karena_error;
  end if;

  -- get data from dat_op_bumi
  select kd_znt, nilai_sistem_bumi
  into v_znt, v_nilaiSistemBumi
  from dat_op_bumi
  where kd_propinsi = v_kdPropinsi
    and kd_dati2 = v_kdDati2
    and kd_kecamatan = v_kdKecamatan
    and kd_kelurahan = v_kdKelurahan
    and kd_blok = v_kdBlok
    and no_urut = v_noUrut
    and kd_jns_op = v_kdJnsOp;

  -- ambil kode sektor dan nama kelurahan
  select kd_sektor, nm_kelurahan
  into v_kdSektor, v_nmKelurahan
  from ref_kelurahan
  where kd_propinsi = v_kdPropinsi
    and kd_dati2 = v_kdDati2
    and kd_kecamatan = v_kdKecamatan
    and kd_kelurahan = v_kdKelurahan;

  -- ambil nama kecamatan
  select nm_kecamatan
  into v_nmKecamatan
  from ref_kecamatan
  where kd_propinsi = v_kdPropinsi
    and kd_dati2 = v_kdDati2
    and kd_kecamatan = v_kdKecamatan;

  -- cek pokok harus sama dengan pbb_yg_harus_dibayar_sppt
  --if(v_pokokTemp != pokok) then
  --  open c_proses_pembayaran for
  --    select '02' as kode_error from dual; -- pokok pembayaran yang dibayarkan berbeda dengan sismiop
  --  return;
  --end if;
  -- update: pembayaran langsung diambil dari db

  -- bila status pembayaran 1 atau v_pokokTemp = 0, tidak perlu dibayarkan, sudah terbayar
  if(v_statusPembayaranSppt = '1' or v_pokokTemp = 0) then
    open c_proses_pembayaran for
      select '03' as kode_error from dual;
    goto exit_karena_error;
  elsif(v_statusPembayaranSppt = 2) then
  -- bila status pembayaran 2, tidak perlu dibayarkan, tagihan dibatalkan
    open c_proses_pembayaran for
      select '04' as kode_error from dual;
    goto exit_karena_error;
  end if;

  -- cek denda
  if(thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,1)) then
    v_dendaTemp := ceil(1 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,2)) then
    v_dendaTemp := ceil(2 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,3)) then
    v_dendaTemp := ceil(3 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,4)) then
    v_dendaTemp := ceil(4 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,5)) then
    v_dendaTemp := ceil(5 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,6)) then
    v_dendaTemp := ceil(6 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,7)) then
    v_dendaTemp := ceil(7 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,8)) then
    v_dendaTemp := ceil(8 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,9)) then
    v_dendaTemp := ceil(9 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,10)) then
    v_dendaTemp := ceil(10 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,11)) then
    v_dendaTemp := ceil(11 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,12)) then
    v_dendaTemp := ceil(12 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,13)) then
    v_dendaTemp := ceil(13 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,14)) then
    v_dendaTemp := ceil(14 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar between (v_tglJatuhTempo+1) and add_months(v_tglJatuhTempo,15)) then
    v_dendaTemp := ceil(15 * 0.02 * v_pokokTemp);
  elsif (thn > '2013' and tgl_bayar >= add_months(v_tglJatuhTempo,15)) then
    v_dendaTemp := ceil(15 * 0.02 * v_pokokTemp);
  else v_dendaTemp := 0;
  end if;

  -- count pembayaran yang sudah masuk
  select count(kd_propinsi) into v_pembayaranKe
  from pembayaran_sppt
  where thn_pajak_sppt = thn
    and kd_propinsi = v_kdPropinsi
    and kd_dati2 = v_kdDati2
    and kd_kecamatan = v_kdKecamatan
    and kd_kelurahan = v_kdKelurahan
    and kd_blok = v_kdBlok
    and no_urut = v_noUrut
    and kd_jns_op = v_kdJnsOp;

  if(v_pembayaranKe = null) then
    v_pembayaranKe := 0;
  end if;

  v_tglRekam := sysdate;
  v_jamRekam := current_timestamp;
  v_pembayaranKe := v_pembayaranKe +1;

  -- simpan pembayaran di tabel pembayaran_sppt
  insert into pembayaran_sppt(kd_propinsi, kd_dati2, kd_kecamatan, kd_kelurahan,
    kd_blok, no_urut, kd_jns_op, thn_pajak_sppt, pembayaran_sppt_ke,
    kd_kanwil_bank, kd_kppbb_bank, kd_bank_tunggal, kd_bank_persepsi, kd_tp,
    denda_sppt, jml_sppt_yg_dibayar, tgl_pembayaran_sppt,
    tgl_rekam_byr_sppt, nip_rekam_byr_sppt)
  values(v_kdPropinsi, v_kdDati2, v_kdKecamatan, v_kdKelurahan,
    v_kdBlok, v_noUrut, v_kdJnsOp, thn, v_pembayaranKe,
    v_kdKanwilBank, v_kdKppbbBank, v_kdBankTunggal, v_kdBankPersepsi, v_kdTp,
    v_dendaTemp, (v_pokokTemp + v_dendaTemp), tgl_bayar,
    v_tglRekam, '060000000');
  commit;

  -- task: susun ntpd
  v_panjangNamaWp := length(v_namaWp);
  v_ntpd := to_char(tgl_bayar,'YYYY') ||
    substr(v_namaWp,-1,1) || substr(v_znt,1,1) || v_panjangNamaWp ||
    substr(to_char(v_nilaiSistemBumi),1,1) ||
    length(to_char(v_nilaiSistemBumi)) || to_char(v_jamRekam,'MI') ||
    substr(v_namaWp,1,1) || substr(v_znt,-1,1) || to_char(tgl_bayar,'DD') ||
    substr(to_char(v_nilaiSistemBumi),-1,1) ||
    substr(to_char(v_pokokTemp),2,1) || to_char(v_jamRekam, 'HH24') ||
    to_char(tgl_bayar,'MM');

  -- respond untuk pembayaran yang sukses
  if (v_kdsektor = '02') then
    v_mataAnggaran := '4.1.1.11.01';
  else
    v_mataAnggaran := '4.1.1.11.02';
  end if;

  v_mataAnggaranSanksi := v_mataAnggaran;

  -- SIMPAN TRANSAKSI DI LOG
  INSERT INTO LOG_TRX_PEMBAYARAN
    (NOP, THN, NTPD, MATA_ANGGARAN, POKOK, MA_SANKSI, DENDA, NAMA_WP, ALAMAT_OP, PEMBAYARAN_KE, ip_client)
  VALUES(nop, thn, v_ntpd, v_mataAnggaran, v_pokokTemp, v_mataAnggaranSanksi, v_dendaTemp, v_namaWp, v_nmKelurahan || ' - ' ||v_nmKecamatan,
    v_pembayaranKe, ip_Client);
  commit;

  open c_proses_pembayaran for
    select nop as nop, thn as thn, v_ntpd as ntpd, v_mataAnggaran as mata_anggaran_pokok,
      v_pokokTemp as pokok, v_mataAnggaranSanksi as mata_anggaran_sanksi, v_dendaTemp as sanksi,
      v_namaWp as nama_wp, v_nmKelurahan || ' - ' || v_nmKecamatan as alamat_op
    from dual;

  <<exit_karena_error>>
  return;
end;
  \end{lstlisting}

\subsection{\textit{STORE PROCEDURE} REVERSAL\_PEMBAYARAN}

\textit{Store procedure} ini akan bertugas melakukan pengembalian data ke kondisi sebelum terjadinya pembayaran. Kode dari \textit{store procedure} ini adalah sebagai berikut :

\begin{lstlisting}
create or replace procedure reversal_pembayaran(c_data out sys_refcursor,
  v_nop in varchar, v_thn in varchar, v_ntpd in varchar, v_ip_client in varchar)
is
  v_adaData numeric;
  v_kdPropinsi sppt.kd_propinsi%type;
  v_kdDati2 sppt.kd_dati2%type;
  v_kdKecamatan sppt.kd_kecamatan%type;
  v_kdKelurahan sppt.kd_kelurahan%type;
  v_kdBlok sppt.kd_blok%type;
  v_noUrut sppt.no_urut%type;
  v_kdJnsOp sppt.kd_jns_op%type;
  v_pembayaranKe log_trx_pembayaran.pembayaran_ke%type;

begin
  -- error code in c_data
  -- 01 : NO DATA FOUND
  -- 02 : DATA GANDA

  -- set parameter nop
  v_kdPropinsi := substr(v_nop,1,2);
  v_kdDati2 := substr(v_nop,3,2);
  v_kdKecamatan := substr(v_nop,5,3);
  v_kdKelurahan := substr(v_nop,8,3);
  v_kdBlok := substr(v_nop,11,3);
  v_noUrut := substr(v_nop,14,4);
  v_kdJnsOp := substr(v_nop,18,1);

  -- verifikasi data, ada atau ga
  select count(log_trx.nop)
  into v_adaData
  from log_trx_pembayaran log_trx
  where log_trx.ntpd = v_ntpd
    and log_trx.nop = v_nop
    and log_trx.thn = v_thn;

  if(v_adaData = 0) then
    open c_data for
      select '01' as kode_error from dual;
    goto exit_karena_error;
  elsif(v_adaData > 1) then
    open c_data for
      select '02' as kode_error from dual;
    goto exit_karena_error;
  end if;

  -- ambil data dari log_trx_pembayaran
  select pembayaran_ke
  into v_pembayaranKe
  from log_trx_pembayaran log_trx
  where log_trx.nop = v_nop
    and log_trx.thn = v_thn
    and log_trx.ntpd = v_ntpd;

  -- hapus data di pembayaran_sppt
  delete from pembayaran_sppt
  where thn_pajak_sppt = v_thn
    and kd_propinsi = v_kdPropinsi
    and kd_dati2 = v_kdDati2
    and kd_kecamatan = v_kdKecamatan
    and kd_kelurahan = v_kdKelurahan
    and kd_blok = v_kdBlok
    and no_urut = v_noUrut
    and kd_jns_op = v_kdJnsOp
    and pembayaran_sppt_ke = v_pembayaranKe;
  commit;

  -- ubah isi sppt.status_pembayaran_sppt = '0'
  update sppt
  set status_pembayaran_sppt = '0'
  where thn_pajak_sppt = v_thn
    and kd_propinsi = v_kdPropinsi
    and kd_dati2 = v_kdDati2
    and kd_kecamatan = v_kdKecamatan
    and kd_kelurahan = v_kdKelurahan
    and kd_blok = v_kdBlok
    and no_urut = v_noUrut
    and kd_jns_op = v_kdJnsOp;
  commit;

  -- catat di log_reversal
  insert into log_reversal log_r
    (log_r.nop, log_r.thn, log_r.ntpd, log_r.ip_client)
  values (v_nop, v_thn, v_ntpd, v_ip_client);
  commit;

  open c_data for
    select v_nop as NOP, v_thn as THN, v_ntpd as NTPD from dual;

  <<exit_karena_error>>
  return;
end;
\end{lstlisting}

\section{\textit{SOURCE CODE BUILD TOOLS}}

Untuk mempermudah pengelolaan ketergantungan pustaka, maka dibutuhkan \textit{build tools}, \textit{build tools} yang sudah teruji kehandalannya dan stabilitas, termasuk cakupan pustaka yang ada, maka maven adalah pilihannya. Berikut adalah kode dari konfigurasi maven yang diperlukan :

\begin{lstlisting}
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>lab.aikibo</groupId>
  <artifactId>learn-spring-rest-hibernate</artifactId>
  <packaging>war</packaging>
  <version>1.0-SNAPSHOT</version>
  <name>learn-spring-rest-hibernate Maven Webapp</name>
  <url>http://maven.apache.org</url>

  <properties>
    <spring.version>4.0.6.RELEASE</spring.version>
    <hibernate.version>4.3.6.Final</hibernate.version>
    <log4j.version>1.2.17</log4j.version>
    <jackson.version>2.7.5</jackson.version>
    <jdk.version>1.7</jdk.version>
  </properties>

  <dependencies>
    <!-- unit testing -->
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>

    <!-- log4j -->
    <dependency>
      <groupId>log4j</groupId>
      <artifactId>log4j</artifactId>
      <version>${log4j.version}</version>
    </dependency>

    <!-- oracle ojdbc -->
    <dependency>
      <groupId>oracle</groupId>
      <artifactId>ojdbc14</artifactId>
      <version>10.2.0.4</version>
    </dependency>

    <!-- spring -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-core</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-web</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-tx</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-orm</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>${spring.version}</version>
    </dependency>

    <!-- hibernate -->
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-core</artifactId>
      <version>${hibernate.version}</version>
    </dependency>
    
    <!-- bonecp -->
    <dependency>
      <groupId>com.jolbox</groupId>
      <artifactId>bonecp-provider</artifactId>
      <version>0.8.0-alpha1</version>
    </dependency>
    <dependency>
      <groupId>com.jolbox</groupId>
      <artifactId>bonecp</artifactId>
      <version>0.8.0.RELEASE</version>
    </dependency>

    <!-- hikaricp, pengganti bonecp -->
    <dependency>
      <groupId>com.zaxxer</groupId>
      <artifactId>HikariCP</artifactId>
      <version>2.4.7</version>
    </dependency>

    <!-- jsr303 validation -->
    <dependency>
      <groupId>javax.validation</groupId>
      <artifactId>validation-api</artifactId>
      <version>1.1.0.Final</version>
    </dependency>
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-validator</artifactId>
      <version>5.1.3.Final</version>
    </dependency>

    <!-- servlet + jsp + jstl -->
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
    </dependency>
    <dependency>
      <groupId>javax.servlet.jsp</groupId>
      <artifactId>javax.servlet.jsp-api</artifactId>
      <version>2.3.1</version>
    </dependency>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>jstl</artifactId>
      <version>1.2</version>
    </dependency>

    <!-- testing dependencies -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-test</artifactId>
      <version>${spring.version}</version>
    </dependency>

    <!-- mocking -->
    <dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-core</artifactId>
      <version>2.2.9</version>
    </dependency>

    <!-- jackson for convert POJO to json format -->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>${jackson.version}</version>
    </dependency>

    <!-- joda time -->
    <dependency>
      <groupId>joda-time</groupId>
      <artifactId>joda-time</artifactId>
      <version>2.9.4</version>
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <finalName>learn-spring-rest-hibernate</finalName>

    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.2</version>
        <configuration>
          <source>${jdk.version}</source>
          <target>${jdk.version}</target>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-war-plugin</artifactId>
        <version>2.4</version>
        <configuration>
          <warSourceDirectory>src/main/webapp</warSourceDirectory>
          <warName>Spring-Rest-Hibernate-Pbb</warName>
          <failOnMissingWebXml>false</failOnMissingWebXml>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
\end{lstlisting}


\section{\textit{SOURCE CODE} KONFIGURASI application.properties}

\textit{File} application.properties ini adalah \textit{file} konfigurasi yang digunakan dalam aplikasi nantinya. Isi dari \textit{file} ini adalah sebagai berikut :

\begin{lstlisting}
jdbc.driverClassName = oracle.jdbc.driver.OracleDriver
jdbc.url = jdbc:oracle:thin:***/***@192.168.2.7:1521/SISMIOP
jdbc.username = PBB
jdbc.password = RAHASIAPBB

hibernate.dialect = org.hibernate.dialect.Oracle10gDialect
hibernate.show_sql = true
hibernate.format_sql = true

# for bonecp
providerClass = com.zaxxer.hikari.hibernate.HikariConnectionProvider
minIdle = 2
maxPool = 30
dataSourceClassName = oracle.jdbc.pool.OracleDataSource
url = jdbc:oracle:thin:***/***@192.168.2.7:1521/sismiopbck
username = ***
password = ***
implicitCache = true
\end{lstlisting}


\section{\textit{SOURCE CODE} KONFIGURASI log4j.properties}

Kode pada \textit{file} log4j.properties ini adalah untuk mengatur keluaran dari \textit{log} atau pencatat aktivitas pada saat sistem aplikasi berjalan, apakah akan dikeluarkan ke monitor, atau dicatatkan dalam \textit{file} tertentu. Isi dari kode pada \textit{file} log4j.properties ini adalah sebagai berikut :

\begin{lstlisting}
# Root logger option
#log4j.rootLogger=TRACE, DEBUG, stdout, file
log4j.rootLogger=DEBUG, stdout, file

log4j.logger.org.hibernate.SQL = debug
log4j.logger.org.hibernate.type=trace

# Redirect log messages to console
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n

# Redirect log messages to a log file, support file rolling.
log4j.appender.file=org.apache.log4j.RollingFileAppender
log4j.appender.file.File=/var/lib/tomcat8/logs/log4j-app.log
log4j.appender.file.MaxFileSize=5MB
log4j.appender.file.MaxBackupIndex=10
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n
\end{lstlisting}


\section{\textit{SOURCE CODE} AppConfig.java}

Kode pada \textit{file} AppConfig.java adalah kode berisi konfigurasi dari \textit{framework} Spring. Isi dari kode tersebut adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;

import lab.aikibo.model.Sppt;
import lab.aikibo.dao.SpptDao;
import lab.aikibo.dao.SpptDaoImpl;

@Configuration
@EnableWebMvc
@ComponentScan(basePackages = {"lab.aikibo"})
@Import({HibernateConfiguration.class})
public class AppConfig {

}
\end{lstlisting}

Kelas AppConfig ini memang kosong, tidak perlu dilakukan pengaturan lain karena pengaturan-pengaturan dasar berada pada tanda \textit{annotation} di atas kelas.


\section{\textit{SOURCE CODE} HibernateConfiguration.java}

Kelas HibernateConfiguration ini adalah tempat untuk konfigurasi \textit{framework} Hibernate yang nantinya berkomunikasi langsung dengan basis data. Kode dari kelas HibernateConfiguration ini adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.config;

import java.util.Properties;

import javax.sql.DataSource;

import org.hibernate.SessionFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.orm.hibernate4.HibernateTransactionManager;
import org.springframework.orm.hibernate4.LocalSessionFactoryBean;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import com.zaxxer.hikari.HikariDataSource;

import com.jolbox.bonecp.BoneCPDataSource;

/**
 * seharusnya ditambahkan bonecp
 *
 * @author Tamami
 */
@Configuration
@EnableTransactionManagement
@ComponentScan({"lab.aikibo.config"})
@PropertySource(value = {"classpath:application.properties"})
public class HibernateConfiguration {
  @Autowired
  private Environment environment;

  @Bean
  public LocalSessionFactoryBean sessionFactory() {
    LocalSessionFactoryBean sessionFactory = new LocalSessionFactoryBean();
    sessionFactory.setDataSource(boneCPDataSource());
    sessionFactory.setPackagesToScan(new String[] {"lab.aikibo.model"});
    sessionFactory.setHibernateProperties(hibernateProperties());
    return sessionFactory;
  }

  @Bean
  public BoneCPDataSource boneCPDataSource() {
    BoneCPDataSource ds = new BoneCPDataSource();
    ds.setDriverClass(environment.getRequiredProperty("jdbc.driverClassName"));
    ds.setJdbcUrl(environment.getRequiredProperty("jdbc.url"));
    ds.setUsername(environment.getRequiredProperty("jdbc.username"));
    ds.setPassword(environment.getRequiredProperty("jdbc.password"));

    ds.setIdleConnectionTestPeriodInMinutes(60);
    ds.setIdleMaxAgeInMinutes(420);
    ds.setMaxConnectionsPerPartition(30);
    ds.setMaxConnectionsPerPartition(10);
    ds.setPartitionCount(10);
    ds.setAcquireIncrement(5);
    ds.setStatementsCacheSize(100);
    ds.setReleaseHelperThreads(3);
    return ds;
  }

  @Bean
  public DataSource dataSource() {
    DriverManagerDataSource dataSource = new DriverManagerDataSource();
    dataSource.setDriverClassName(environment.getRequiredProperty("jdbc.driverClassName"));
    dataSource.setUrl(environment.getRequiredProperty("jdbc.url"));
    dataSource.setUsername(environment.getRequiredProperty("jdbc.username"));
    dataSource.setPassword(environment.getRequiredProperty("jdbc.password"));

    return dataSource;
  }

  private Properties hibernateProperties() {
    Properties properties = new Properties();
    properties.put("hibernate.dialect", environment.getRequiredProperty("hibernate.dialect"));
    properties.put("hibernate.show_sql", environment.getRequiredProperty("hibernate.show_sql"));
    properties.put("hibernate.format_sql", environment.getRequiredProperty("hibernate.format_sql"));

    properties.put("hibernate.hbm2ddl.auto", "validate");

    return properties;
  }

  @Bean
  @Autowired
  public HibernateTransactionManager transactionManager(SessionFactory sf) {
    HibernateTransactionManager txManager = new HibernateTransactionManager();
    txManager.setSessionFactory(sf);
    return txManager;
  }
}
\end{lstlisting}

\section{\textit{SOURCE CODE} SerialConstant.java}

Kelas SerialConstant akan berisi kode untuk kelas yang bersifat Serializable, karena setiap kelas yang mengimplementasikan Serializable memerlukan identitas untuk instan yang terbentuk. Berikut adalah isi dari kode kelas SerialConstant :

\begin{lstlisting}
package lab.aikibo.constant;

public class SerialConstant {

  public static final long SERIAL_SPPT = 1L;
  public static final long SERIAL_SPPT_PK = 2L;
  public static final long SERIAL_SPPT_SISMIOP = 3L;
  public static final long SERIAL_SPPT_SISMIOP_PK = 4L;
  public static final long SERIAL_REF_KELURAHAN = 5L;
  public static final long SERIAL_REF_KELURAHAN_PK = 6L;
  public static final long SERIAL_REF_KECAMATAN = 7L;
  public static final long SERIAL_REF_KECAMATAN_PK = 8L;
  public static final long SERIAL_PEMBAYARAN_SPPT = 9L;
  public static final long SERIAL_PEMBAYARAN_SPPT_PK = 10L;
  public static final long SERIAL_REVERSAL_PEMBAYARAN = 11L;

}
\end{lstlisting}


\section{\textit{SOURCE CODE} StatusRespond.java}

Kelas StatusRespond ini akan menampung informasi kode respon yang akan diberikan ke \textit{client}, agar memudahkan sistem aplikasi melakukan respon dan mencegah redundansi baris kode yang sama berulang-ulang. Kode dari kelas StatusRespond ini adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.constant;

public class StatusRespond {

  public static final int APPROVED = 1;
  public static final int DATA_INQ_NIHIL = 10;
  public static final int TAGIHAN_TELAH_TERBAYAR = 13;
  public static final int JUMLAH_SETORAN_NIHIL = 03; // pbb = 0 rupiah
  public static final int DATABASE_ERROR = 04;
  public static final int ERROR_PEMBUATAN_NTPD = 05;
  public static final int JUMLAH_PEMBAYARAN_BUKAN_ANGKA = 31;
  public static final int TGL_JAM_BAYAR_LD_TGL_JAM_KIRIM = 32;
  public static final int TGL_KIRIM_REV_LD_1H_ORI = 33;
  public static final int PROC_CODE_NOT_VALID = 34;
  public static final int MASA_PAJAK_BUKAN_ANGKA = 35;
  public static final int THN_PAJAK_BUKAN_ANGKA = 36;

}
\end{lstlisting}


\section{\textit{SOURCE CODE} SpptRestController.java}

Kelas ini nantinya akan menangani seluruh \textit{request} yang masuk dari \textit{client}. Kode untuk kelas ini adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.controller;

import org.apache.log4j.Logger;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.RequestMethod;

import java.math.BigInteger;

import javax.servlet.http.HttpServletRequest;

import lab.aikibo.constant.StatusRespond;
import lab.aikibo.model.Sppt;
import lab.aikibo.model.SpptJ;
import lab.aikibo.model.Status;
import lab.aikibo.model.StatusInq;
import lab.aikibo.model.StatusTrx;
import lab.aikibo.model.StatusRev;
import lab.aikibo.model.Message;
import lab.aikibo.services.SpptServices;
import lab.aikibo.services.PembayaranServices;
import lab.aikibo.services.ReversalServices;

import org.joda.time.DateTime;

/**
 * Mapping Rest dengan pola berikut :
 *
 * /Spring-Rest-Hibernate-Pbb/sppt/{nop}/{thn}
 *   untuk inquiry data PBB
 *
 * /Spring-Rest-Hibernate-Pbb/bayar/{nop}/{thn}/{tglBayar}/{jamBayar}
 *   untuk melakukan pencatatan pembayaran, request ini akan secara otomatis mencatatkan pembayaran
 *   ke tabel pembayaran_sppt, bila ada kesalahan, maka perlu request reversal
 *   Format tglBayar: DDMMYYYY
 *   Format jamBayar: HH24MI
 *
 * /Spring-Rest-Hibernate-Pbb/reversal/{nop}/{thn}/{ntpd}
 *   melakukan reversal atas pencatatan pembayaran sebelumnya.
 *
 * @author: tamami
 */
@RestController
public class SpptRestController {

	@Autowired
	SpptServices spptServices;

	@Autowired
	PembayaranServices pembayaranServices;

	@Autowired
	ReversalServices reversalServices;

	static final Logger logger = Logger.getLogger(SpptRestController.class);

	public static Logger getLogger() {
		return logger;
	}

	@RequestMapping("/")
	public String welcome() {
		String info = "Selamat Datang<br>";
		info += "gunakan perintah berikut:<br>";
		info += "<dl>";
		info += "<dt>sppt/{nop}/{thn}</dt>";
		info += "<dd>untuk inquiry data per nop</dd>";
		info += "<dt>bayar/{nop}/{thn}/{tglBayar}/{jamBayar}</dt>";
		info += "<dd>untuk melakukan pembayaran, data akan otomatis tersimpan sebagai transaksi pembayaran apabila ini di-request</dd>";
		info += "<dt>reversal/{nop}/{thn}/{ntpd}</dt>";
		info += "<dd>untuk melakukan reversal pembayaran</dd>";
		info += "</dl>";
		return info;
	}

	// single inquiry
	@RequestMapping(value="/sppt/{nop}/{thn}", method = RequestMethod.GET)
	public StatusInq getDataSppt(@PathVariable("nop") String nop, @PathVariable("thn") String thnPajak,
	    HttpServletRequest request) {
		logger.debug("NOP: " + nop);
		logger.debug("THN: " + thnPajak);
		String ipClient = request.getHeader("X-FORWARDED-FOR");
		if(ipClient == null) {
			ipClient = request.getRemoteAddr();
		}
		StatusInq status = null;

		// test thnPajak
		try {
			Integer.parseInt(thnPajak);
		} catch(NumberFormatException ex) {
			status = new StatusInq(StatusRespond.THN_PAJAK_BUKAN_ANGKA, "Tahun Pajak Mengandung Karakter bukan Angka", null);
			return status;
		}

		try {
			status = spptServices.getSpptByNopThn(nop, thnPajak, ipClient);
		} catch(Exception e) {
			logger.error(e);
		}
		logger.debug(" >>> GetData >>> " + status);
		return status;
	}

	// single transaction
	// format tanggal : DDMMYYYY
	// format jam : HH24MI
  @RequestMapping(value="/bayar/{nop}/{thn}/{tglBayar}/{jamBayar}", method = RequestMethod.GET)
	public StatusTrx prosesPembayaran(@PathVariable("nop") String nop,
			@PathVariable("thn") String thnPajak, @PathVariable("tglBayar") String tglBayarString,
			@PathVariable("jamBayar")String jamBayarString, HttpServletRequest request) {
	  StatusTrx status = null;
		BigInteger pokok = null;
		BigInteger denda = null;
		String ipClient = request.getHeader("X-FORWARDED-FOR");
		if(ipClient == null) {
			ipClient = request.getRemoteAddr();
		}
		logger.debug(" >>> IP CLIENT: " + ipClient);

		// cek tanggal bayar, tidak boleh lebih baru daripada tanggal saat ini
		int date = Integer.parseInt(tglBayarString.substring(0,2));
		int month = Integer.parseInt(tglBayarString.substring(2,4));
		int year = Integer.parseInt(tglBayarString.substring(4,8));
		int hour = Integer.parseInt(jamBayarString.substring(0,2));
		int min = Integer.parseInt(jamBayarString.substring(2,4));

		DateTime tglBayar = new DateTime(year, month, date, hour, min);
		if(tglBayar.isAfterNow()) {
			// keluarkan pesan error
			status = new StatusTrx(StatusRespond.TGL_JAM_BAYAR_LD_TGL_JAM_KIRIM,
			    "Tanggal atau jam pada saat dibayarkan melebihi tanggal dan jam saat ini", null);
			return status;
		}

    // proses pembayaran
		try {
      status = pembayaranServices.prosesPembayaran(nop, thnPajak, tglBayar, ipClient);
		} catch(Exception e) {
			logger.error(e);
			logger.debug(" >>> GetData >>> " + status);
		}

		return status;
	}

	@RequestMapping(value="/reversal/{nop}/{thn}/{ntpd}", method = RequestMethod.GET)
	public StatusRev prosesReversal(@PathVariable("nop") String nop,
	    @PathVariable("thn") String thn, @PathVariable("ntpd") String ntpd,
			HttpServletRequest request) {
    StatusRev status = null;

		// get IP Client
		String ipClient = request.getHeader("X-FORWARDED-FOR");
		if(ipClient == null) {
			ipClient = request.getRemoteAddr();
		}
		logger.debug(" >>> IP CLIENT: " + ipClient);

		try {
			status = reversalServices.prosesReversal(nop, thn, ntpd, ipClient);
		} catch(Exception ex) {
			logger.error(ex);
			logger.debug(" >>> GetData >>> " + status);
		}
		return status;
	}

	@RequestMapping(value="/info/{user}", method = RequestMethod.GET)
	public Message getMessage(@PathVariable String user) {
		Message msg = new Message(user, "Halo " + user);
		return msg;
	}

}
\end{lstlisting}


\section{\textit{SOUCE CODE} StoreProceduresDao.java}

Kode StoreProceduresDao.java merupakan \textit{interface} yang nantinya menjadi kerangka yang dibutuhkan \textit{framework} Spring dalam mengorganisasi kelas-kelas yang nantinya akan melakukan komunikasi dengan basis data. Kode dari \textit{interface} StoreProceduresDao adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.dao;

import lab.aikibo.model.StatusInq;
import lab.aikibo.model.StatusTrx;
import lab.aikibo.model.StatusRev;

import java.util.Date;

public interface StoreProceduresDao {
  public StatusInq getDataSppt(String nop, String thn, String ipClient);
  public StatusTrx prosesPembayaran(String nop, String thn, Date tglBayar, String ipClient);
  public StatusRev reversalPembayaran(String nop, String thn, String ntpd, String ipClient);
}
\end{lstlisting}


\section{\textit{SOURCE CODE} StoreProceduresDaoImpl.java}

Kode pada \textit{file} StoreProceduresDaoImpl.java adalah kelas yang mengimplementasikan \textit{interface} StoreProceduresDao yang nantinya akan melakukan komunikasi dengan sistem basis data. Kode dari kelas StoreProceduresDaoImpl adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.dao;

import org.springframework.stereotype.Repository;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;

import java.sql.Connection;
import java.sql.CallableStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

import java.math.BigInteger;
import java.util.Date;

import javax.persistence.ParameterMode;

import org.hibernate.SessionFactory;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.jdbc.Work;
import org.hibernate.procedure.ProcedureCall;
import org.hibernate.result.Output;
import org.hibernate.result.ResultSetOutput;

import org.joda.time.DateTime;
import org.joda.time.Months;

import oracle.jdbc.OracleTypes;

import com.jolbox.bonecp.BoneCPDataSource;

import lab.aikibo.model.Sppt;
import lab.aikibo.model.SpptJ;
import lab.aikibo.model.StatusInq;
import lab.aikibo.model.StatusRev;
import lab.aikibo.model.SpptSismiop;
import lab.aikibo.model.StatusTrx;
import lab.aikibo.model.PembayaranSppt;
import lab.aikibo.model.ReversalPembayaran;

import lab.aikibo.constant.StatusRespond;

import lab.aikibo.controller.SpptRestController;

@Repository("storeProceduresDao")
public class StoreProceduresDaoImpl implements StoreProceduresDao {

  @Autowired
  private SessionFactory sessionFactory;
  @Autowired
  private BoneCPDataSource boneCPDs;

  CallableStatement callable;
  Sppt sppt;
  PembayaranSppt pembayaranSppt;
  ReversalPembayaran revPembayaran;
  StatusInq status;
  StatusTrx statusTrx;
  StatusRev statusRev;

  public StatusInq getDataSppt(String nop, String thn, String ipClient) {
    // -- ini cara 1; lumpuh saat panggil ke connection() deprecated

    callable = null;
    sppt = null;
    status = null;

    try {
      callable = boneCPDs.getConnection().prepareCall("call sppt_terhutang(?,?,?)");
      callable.registerOutParameter(1, OracleTypes.CURSOR);
      callable.setString(2, nop);
      callable.setString(3, thn);
      //if(callable.executeUpdate() == 0) {
      callable.executeUpdate();
      ResultSet rs = (ResultSet) callable.getObject(1);
      ResultSetMetaData rsmd = rs.getMetaData();
      for(int i=1; i<rsmd.getColumnCount(); i++) {
        SpptRestController.getLogger().debug(" >>> data " + i + " : " + rsmd.getColumnName(i));
      }
      sppt = new Sppt();

      while(rs.next()) {
        String nama = rs.getString("NAMA");
        String alamatOp = rs.getString("ALAMAT_OP");
        BigInteger pokok = rs.getBigDecimal("POKOK").toBigInteger();
        BigInteger denda = rs.getBigDecimal("DENDA").toBigInteger();
        SpptRestController.getLogger().debug(" >>> NAMA : " + nama);
        SpptRestController.getLogger().debug(" >>> ALAMAT OP : " + alamatOp);
        SpptRestController.getLogger().debug(" >>> POKOK : " + pokok);
        SpptRestController.getLogger().debug(" >>> DENDA : " + denda);
        sppt.setNop(nop);
        sppt.setThn(thn);
        sppt.setNama(nama);
        sppt.setAlamatOp(alamatOp);
        sppt.setPokok(pokok);
        sppt.setDenda(denda);
      }
      if(sppt.getNop() == null) {
        status = new StatusInq(StatusRespond.DATA_INQ_NIHIL, "Data Tidak Ditemukan", null);
        return status;
      }

      status = new StatusInq(StatusRespond.APPROVED, "Data ditemukan", sppt);
      return status;
    } catch(Exception e) {
      status = new StatusInq(StatusRespond.DATABASE_ERROR, "Kesalahan DB", null);
    }
    return status;
  }

  public StatusTrx prosesPembayaran(String nop, String thn, Date tglBayar, String ipClient) {
    callable = null;
    pembayaranSppt = null;
    statusTrx = null;

    try {
      callable = boneCPDs.getConnection().prepareCall("call proses_pembayaran(?,?,?,?,?)");
      callable.registerOutParameter(1, OracleTypes.CURSOR);
      callable.setString(2, nop);
      callable.setString(3, thn);
      callable.setDate(4, new java.sql.Date(tglBayar.getTime()));
      callable.setString(5, ipClient);

      callable.executeUpdate();
      ResultSet rs = (ResultSet) callable.getObject(1);
      ResultSetMetaData rsMeta = rs.getMetaData();
      pembayaranSppt = new PembayaranSppt();
      while(rs.next()) {
        SpptRestController.getLogger().debug(" >>> Berhasil masuk iterasi rs.next");
        SpptRestController.getLogger().debug(" >>> nama kolom yang ada : " + rsMeta.getColumnName(1));
        if(!rsMeta.getColumnName(1).equals("KODE_ERROR")) {
          SpptRestController.getLogger().debug(" >>> nop-nya ada : " + rs.getString("nop"));
          pembayaranSppt.setNop(rs.getString("NOP"));
          pembayaranSppt.setThn(rs.getString("THN"));
          pembayaranSppt.setNtpd(rs.getString("NTPD"));
          pembayaranSppt.setMataAnggaranPokok(rs.getString("MATA_ANGGARAN_POKOK"));
          pembayaranSppt.setPokok(rs.getBigDecimal("POKOK").toBigInteger());
          pembayaranSppt.setMataAnggaranSanksi(rs.getString("MATA_ANGGARAN_POKOK"));
          pembayaranSppt.setSanksi(rs.getBigDecimal("SANKSI").toBigInteger());
          pembayaranSppt.setNamaWp(rs.getString("NAMA_WP"));
          pembayaranSppt.setAlamatOp(rs.getString("ALAMAT_OP"));
        } else {
          String infoSp = rs.getString("KODE_ERROR");
          if(infoSp.equals("01")) {
            statusTrx = new StatusTrx(StatusRespond.TAGIHAN_TELAH_TERBAYAR, "Tagihan Telah Terbayar atau Pokok Pajak Nihil.", null);
            return statusTrx;
          } else if(infoSp.equals("02")) {
            // not used
          } else if(infoSp.equals("03")) {
            statusTrx = new StatusTrx(StatusRespond.TAGIHAN_TELAH_TERBAYAR, "Tagihan Telah Terbayar", null);
            return statusTrx;
          } else if(infoSp.equals("04")) {
            statusTrx = new StatusTrx(StatusRespond.JUMLAH_SETORAN_NIHIL, "Tagihan SPPT Telah Dibatalkan", null);
            return statusTrx;
          }
        }
      }
      statusTrx = new StatusTrx(StatusRespond.APPROVED, "Pembayaran Telah Tercatat", pembayaranSppt);
    } catch(Exception ex) {
      SpptRestController.getLogger().debug(" >>> hasil Exception : " + ex);
      statusTrx = new StatusTrx(StatusRespond.DATABASE_ERROR, "Kesalahan Server", null);
      return statusTrx;
    }

    return statusTrx;
  }

  public StatusRev reversalPembayaran(String nop, String thn, String ntpd, String ipClient) {
    callable = null;
    revPembayaran = null;
    statusRev = null;

    try {
      callable = boneCPDs.getConnection().prepareCall("call reversal_pembayaran(?,?,?,?,?)");
      callable.registerOutParameter(1, OracleTypes.CURSOR);
      callable.setString(2, nop);
      callable.setString(3, thn);
      callable.setString(4, ntpd);
      callable.setString(5, ipClient);
      callable.executeUpdate();

      ResultSet rs = (ResultSet) callable.getObject(1);
      ResultSetMetaData rsMeta = rs.getMetaData();
      ReversalPembayaran revBayar = new ReversalPembayaran();
      while(rs.next()) {
        if(!rsMeta.getColumnName(1).equals("KODE_ERROR")) {
          revBayar.setNop(rs.getString("NOP"));
          revBayar.setThn(rs.getString("THN"));
          revBayar.setNtpd(rs.getString("NTPD"));
          statusRev = new StatusRev(StatusRespond.APPROVED, "Proses Reversal Berhasil", revBayar);
        } else {
          String infoSp = rs.getString("KODE_ERROR");
          if(infoSp.equals("01")) {
            statusRev = new StatusRev(StatusRespond.DATA_INQ_NIHIL, "Data Yang Diminta Tidak Ada", null);
            return statusRev;
          } else if(infoSp.equals("02")) {
            statusRev = new StatusRev(StatusRespond.DATABASE_ERROR, "Data tersebut Ganda", null);
            return statusRev;
          }
        }
      }
    } catch(Exception ex) {
      SpptRestController.getLogger().debug(" >>> hasil Exception : " + ex);
      statusRev = new StatusRev(StatusRespond.DATABASE_ERROR, "Kesalahan Server", null);
      return statusRev;
    }
    return statusRev;
  }

  private BigInteger hitungDenda(BigInteger pokok, Date tglJatuhTempo) {
    DateTime start = new DateTime(tglJatuhTempo);
    DateTime end = new DateTime();
    int selisih = selisihBulan(start, end);
    if(selisih < 0) return new BigInteger("0");
    else return new BigInteger("0");

  }

  public int selisihBulan(DateTime start, DateTime end) {
    return Months.monthsBetween(start.withDayOfMonth(start.getDayOfMonth()),
        end.withDayOfMonth(start.getDayOfMonth())).getMonths();
  }

}
\end{lstlisting}


\section{\textit{SOURCE CODE} AppInitializer.java}

\textit{File} AppInitializer.java berisi kelas yang akan dipanggil atau dieksekusi pertama kali oleh \textit{framework} Spring karena mengimplementasikan \textit{interface} AbstractAnnotationConfigDispatcherServletInitializer. Isi dari kelas AppInitializer adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.init;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

import lab.aikibo.config.AppConfig;

public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

  @Override
  protected Class<?>[] getRootConfigClasses() {
    return new Class[] {AppConfig.class};
  }

  @Override
  protected Class<?>[] getServletConfigClasses() {
    return null;
  }

  @Override
  protected String[] getServletMappings() {
    return new String[] { "/" };
  }

}
\end{lstlisting}


\section{\textit{SOURCE CODE} PembayaranSppt.java}

\textit{File} PembayaranSppt.java berisi kelas yang nantinya menampung data yang dikembalikan dari sistem basis data karena ada \textit{request} pencatatan pembayaran dari \textit{client}. Kode untuk kelas ini adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.model;

import java.io.Serializable;

import java.math.BigInteger;

import lab.aikibo.constant.SerialConstant;

public class PembayaranSppt implements Serializable {

  private static final long serialVersionUID = SerialConstant.SERIAL_PEMBAYARAN_SPPT;

  private String nop;
  private String thn;
  private String ntpd;
  private String mataAnggaranPokok;
  private BigInteger pokok;
  private String mataAnggaranSanksi;
  private BigInteger sanksi;
  private String namaWp;
  private String alamatOp;

  // --- constructors

  public PembayaranSppt() {}

  public PembayaranSppt(String nop, String thn, String ntpd,
      String mataAnggaranPokok, BigInteger pokok, String mataAnggaranSanksi,
      BigInteger sanksi, String namaWp, String alamatOp) {
    this.nop = nop;
    this.thn = thn;
    this.ntpd = ntpd;
    this.mataAnggaranPokok = mataAnggaranPokok;
    this.pokok = pokok;
    this.mataAnggaranSanksi = mataAnggaranSanksi;
    this.sanksi = sanksi;
    this.namaWp = namaWp;
    this.alamatOp = alamatOp;
  }


  // -- setter getter

  public String getNop() { return nop; }

  public void setNop(String nop) { this.nop = nop; }

  public String getThn() { return thn; }

  public void setThn(String thn) { this.thn = thn; }

  public String getNtpd() { return ntpd; }

  public void setNtpd(String ntpd) { this.ntpd = ntpd; }

  public String getMataAnggaranPokok() { return mataAnggaranPokok; }

  public void setMataAnggaranPokok(String mataAnggaranPokok) { this.mataAnggaranPokok = mataAnggaranPokok; }

  public BigInteger getPokok() { return pokok; }

  public void setPokok(BigInteger pokok) { this.pokok = pokok; }

  public String getMataAnggaranSanksi() { return mataAnggaranSanksi; }

  public void setMataAnggaranSanksi(String mataAnggaranSanksi) { this.mataAnggaranSanksi = mataAnggaranSanksi; }

  public BigInteger getSanksi() { return sanksi; }

  public void setSanksi(BigInteger sanksi) { this.sanksi = sanksi; }

  public String getNamaWp() { return namaWp; }

  public void setNamaWp(String namaWp) { this.namaWp = namaWp; }

  public String getAlamatOp() { return alamatOp; }

  public void setAlamatOp(String alamatOp) { this.alamatOp = alamatOp; }

}
\end{lstlisting}


\section{\textit{SOURCE CODE} ReversalPembayaran.java}

Isi dari \textit{file} ReversalPembayaran.java adalah kelas ReversalPembayaran yang bertugas menampung data yang dikembalikan dari sistem basis data karena adanya \textit{request reversal} pembayaran dari \textit{client}. Berikut adalah isi dari kodenya :

\begin{lstlisting}
package lab.aikibo.model;

import java.io.Serializable;

import lab.aikibo.constant.SerialConstant;

public class ReversalPembayaran implements Serializable {

  private static final long serialVersionUID = SerialConstant.SERIAL_REVERSAL_PEMBAYARAN;

  private String nop;
  private String thn;
  private String ntpd;

  public ReversalPembayaran() {};

  public ReversalPembayaran(String nop, String thn, String ntpd) {
    this.nop = nop;
    this.thn = thn;
    this.ntpd = ntpd;
  }

  // --- setter getter

  public String getNop() { return nop; }

  public void setNop(String nop) { this.nop = nop; }

  public String getThn() { return thn; }

  public void setThn(String thn) { this.thn = thn; }

  public String getNtpd() { return ntpd; }

  public void setNtpd(String ntpd) { this.ntpd = ntpd; }

}
\end{lstlisting}


\section{\textit{SOURCE CODE} Sppt.java}

Isi dari \textit{file} Sppt.java adalah kelas Sppt yang bertugas menyimpan data hasil kembalian dari sistem basis data untuk permintaan / \textit{request inquiry} data tagihan PBB-P2. Baris kode dari kelas Sppt ini adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.model;

import java.io.Serializable;
import java.math.BigInteger;

import javax.persistence.Embeddable;
import javax.persistence.EmbeddedId;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.IdClass;
import javax.persistence.Id;
import javax.persistence.AttributeOverrides;
import javax.persistence.AttributeOverride;
import javax.persistence.Column;

import lab.aikibo.constant.SerialConstant;

@Entity
@Table(name="sppt_terhutang_matre")
@IdClass(Sppt.SpptPK.class)
public class Sppt implements Serializable {

	private static final long serialVersionUID = SerialConstant.SERIAL_SPPT;

	@Id
	@Column(name="NOP", columnDefinition="char")
  private String nop;
	@Id
	@Column(name="THN", columnDefinition="char")
	private String thn;
	@Column(name="NAMA")
	private String nama;
	@Column(name="ALAMAT_OP")
	private String alamatOp;
	@Column(name="POKOK")
	private BigInteger pokok;
	@Column(name="DENDA")
	private BigInteger denda;



	private String statusPembayaran;

	// --- setter getter

	public String getNop() {
		return nop;
	}

	public void setNop(String nop) {
		this.nop = nop;
	}

	public String getThn() {
		return thn;
	}

	public void setThn(String thn) {
		this.thn = thn;
	}

	public String getNama() {
		return nama;
	}

	public void setNama(String nama) {
		this.nama = nama;
	}

	public String getAlamatOp() {
		return alamatOp;
	}

	public void setAlamatOp(String alamatOp) {
		this.alamatOp = alamatOp;
	}

	public BigInteger getPokok() {
		return pokok;
	}

	public void setPokok(BigInteger pokok) {
		this.pokok = pokok;
	}

	public BigInteger getDenda() {
		return denda;
	}

	public void setDenda(BigInteger denda) {
		this.denda = denda;
	}

	public String getStatusPembayaran() {
		return statusPembayaran;
	}

	public void setStatusPembayaran(String statusPembayaran) {
		this.statusPembayaran = statusPembayaran;
	}


	// --- inner class
	@Embeddable
	public static class SpptPK implements Serializable {
		private static final long serialVersionUID = SerialConstant.SERIAL_SPPT_PK;

		protected String nop;
		protected String thn;

		public SpptPK() {}

		public SpptPK(String nop, String thn) {
			this.nop = nop;
			this.thn = thn;
		}

		public String getNop() {
			return nop;
		}

		public String getThn() {
			return thn;
		}

		public void setNop(String nop) {
			this.nop = nop;
		}

		public void setThn(String thn) {
			this.thn = thn;
		}

	}

}
\end{lstlisting}


\section{\textit{SOURCE CODE} Status.java}

Isi dari \textit{file} Status.java adalah kelas Status yang merupakan kelas umum untuk menampilkan informasi ke \textit{client} terhadap \textit{request} yang diterima. Isi kode dari kelas Status ini adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.model;

public class Status {
	
	private int code;
	private String message;
	
	public Status() {}
	
	public Status(int code, String message) {
		this.code = code;
		this.message = message;
	}
	
	public int getCode() {
		return code;
	}
	
	public String getMessage() {
		return message;
	}
	
	public void setCode(int code) {
		this.code = code;
	}
	
	public void setMessage(String message) {
		this.message = message;
	}

}
\end{lstlisting}


\section{\textit{SOURCE CODE} StatusInq.java}

Isi dari \textit{file} StatusInq.java ini adalah kelas StatusInq yang akan membungkus informasi untuk dikirimkan ke \textit{client} terhadap \textit{request inquiry} yang diterima. Kode dari kelas StatusInq ini adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.model;

public class StatusInq extends Status {
  private Sppt sppt;

  public StatusInq() {}

  public StatusInq(int code, String message, Sppt sppt) {
    super(code, message);
    this.sppt = sppt;
  }

  public Sppt getSppt() { return sppt; }

  public void setSppt(Sppt sppt) { this.sppt = sppt; }

}
\end{lstlisting}


\section{\textit{SOURCE CODE} StatusRev.java}

Isi dari \textit{file} StatusRev.java adalah kelas StatusRev yang nantinya akan membungkus informasi yang akan dikirimkan ke \textit{client} terhadap \textit{request reversal} yang dikirimkan oleh \textit{client} ke \textit{server}. Kode dari kelas StatusRev ini adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.model;

public class StatusRev extends Status {
  private ReversalPembayaran revPembayaran;

  public StatusRev() {}

  public StatusRev(int code, String message, ReversalPembayaran revPembayaran) {
    super(code, message);
    this.revPembayaran = revPembayaran;
  }

  // --- getter setter
  public ReversalPembayaran getRevPembayaran() { return revPembayaran; }

  public void setRevPembayaran(ReversalPembayaran revPembayaran) { this.revPembayaran = revPembayaran; }
}
\end{lstlisting}


\section{\textit{SOURCE CODE} StatusTrx.java}

Isi dari \textit{file} StatusTrx.java adalah kelas StatusTrx yang akan menampung informasi yang akan dikirimkan ke \textit{client} terhadap \textit{request} pencatatan pembayaran yang datang dari \textit{client}. Kode dari kelas StatusTrx adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.model;

public class StatusTrx extends Status {

  private PembayaranSppt byrSppt;

  public StatusTrx() {}

  public StatusTrx(int code, String message, PembayaranSppt byrSppt) {
    super(code, message);
    this.byrSppt = byrSppt;
  }

  // --- setter getter

  public PembayaranSppt getByrSppt() {
    return byrSppt;
  }

  public void setByrSppt(PembayaranSppt byrSppt) {
    this.byrSppt = byrSppt;
  }

}
\end{lstlisting}


\section{\textit{SOURCE CODE} PembayaranServices.java}

Isi dari \textit{file} PembayaranServices.java adalah \textit{interface} PembayaranServices yang berfungsi sebagai objek umum dari layanan pencatatan pembayaran. Kode dari \textit{interface} PembayaranServices ini adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.services;

import lab.aikibo.model.StatusTrx;
import java.math.BigInteger;

import org.joda.time.DateTime;

public interface PembayaranServices {
  public StatusTrx prosesPembayaran(String nop, String thn, DateTime tglBayar, String ipClient);
}
\end{lstlisting}


\section{\textit{SOURCE CODE} PembayaranServicesImpl.java}

Isi dari \textit{file} PembayaranServicesImpl.java adalah kelas PembayaranServicesImpl yang merupakan implementasi dari \textit{interface} PembayaranServices. Kelas ini nantinya akan melakukan pengolahan data apa saja yang perlu diambilkan dari basis data, dan seperti apa pengolahannya. Kode dari kelas PembayaranServicesImpl ini adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.services;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lab.aikibo.dao.StoreProceduresDao;

import lab.aikibo.model.StatusTrx;

import org.joda.time.DateTime;

@Service("pembayaranServices")
@Transactional
public class PembayaranServicesImpl implements PembayaranServices {
  @Autowired
  private StoreProceduresDao spDao;

  @Override
  public StatusTrx prosesPembayaran(String nop, String thn, DateTime tglBayar, String ipClient) {
    return spDao.prosesPembayaran(nop, thn, tglBayar.toDate(), ipClient);
  }
}
\end{lstlisting}


\section{\textit{SOURCE CODE} ReversalServices.java}

Isi dari \textit{file} ReversalServices.java adalah \textit{interface} ReversalServices yang merupakan bentuk umum dari pengolah data untuk \textit{request reversal}. Kode dari \textit{interface} ReversalServices ini adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.services;

import lab.aikibo.model.StatusRev;

public interface ReversalServices {
  public StatusRev prosesReversal(String nop, String thn, String ntpd, String ipClient);
}
\end{lstlisting}


\section{\textit{SOURCE CODE} ReversalServicesImpl.java}

Isi dari \textit{file} ReversalServicesImpl.java adalah kelas ReversalServicesImpl yang merupakan implementasi dari \textit{interface} kelas ReversalServices yang nantinya menangani pengolahan data terhadap \textit{request reversal} dari \textit{client}. Kode dari kelas ReversalServicesImpl ini adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.services;

import lab.aikibo.model.StatusRev;

import lab.aikibo.dao.StoreProceduresDao;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service("reversalServices")
@Transactional
public class ReversalServicesImpl implements ReversalServices {

  @Autowired
  private StoreProceduresDao spDao;

  public StatusRev prosesReversal(String nop, String thn, String ntpd, String ipClient) {
    return spDao.reversalPembayaran(nop, thn, ntpd, ipClient);
  }
}
\end{lstlisting}


\section{\textit{SOURCE CODE} SpptServices.java}

Isi dari \textit{file} SpptServices.java adalah \textit{interface} SpptService yang merupakan bentuk umum dari kelas yang menangani \textit{request inquiry} data dari \textit{client}. Kode dari \textit{interface} SpptServices adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.services;

import lab.aikibo.model.StatusInq;

public interface SpptServices {

	public StatusInq getSpptByNopThn(String nop, String thn, String ipClient);

}
\end{lstlisting}


\section{\textit{SOURCE CODE} SpptServicesImpl.java}

Isi dari \textit{file} SpptServicesImpl.java adalah kelas SpptServicesImpl yang merupakan implementasi dari \textit{interface} SpptServices. Kode dari kelas SpptServicesImpl ini adalah sebagai berikut :

\begin{lstlisting}
package lab.aikibo.services;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lab.aikibo.dao.SpptDao;
import lab.aikibo.dao.StoreProceduresDao;
import lab.aikibo.model.Sppt;
import lab.aikibo.model.SpptJ;
import lab.aikibo.model.StatusInq;
import lab.aikibo.controller.SpptRestController;

@Service("sppt")
@Transactional
public class SpptServicesImpl implements SpptServices {

	@Autowired
	private SpptDao spptDao;

	@Autowired
	private StoreProceduresDao spDao;

	@Override
	public StatusInq getSpptByNopThn(String nop, String thn, String ipClient) {
		//return spptDao.inqSpptByNopThn(nop, thn);
		return spDao.getDataSppt(nop, thn, ipClient);
	}

}
\end{lstlisting}


\end{document}